<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>张杰的日志</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="张杰的日志">
<meta property="og:url" content="http://chapter007.github.io/blog/index.html">
<meta property="og:site_name" content="张杰的日志">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="张杰的日志">
  
    <link rel="alternate" href="/blog/atom.xml" title="张杰的日志" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">张杰的日志</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/blog/" id="subtitle">记录学习生活</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://chapter007.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="content-2017-10-22-写写日记" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-22-写写日记.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.435Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-22-写写日记.md">дд�ռ�</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="дд�ռae���¼һ��ѧϰ״̬"><a href="#дд�ռae���¼һ��ѧϰ״̬" class="headerlink" title="дд�ռǣ���¼һ��ѧϰ״̬"></a>дд�ռǣ���¼һ��ѧϰ״̬</h2><p>�����������ã������춼�ǣ������죬�е�����</p>
<p>��ѧ�������������ˣ��ڱ��ʵ���������죬��Ȼ�������е��о��������е����루�����Ǳ�������ʦ�󵼵ģ�<br>�ܿ��ģ��ϸ������ĵ�����ͨ���ˣ��������õ����о������ĵĵ�һ��ʵϰ������ͦ�м����ǵĵ�ʦ�ģ���Ȼ��Ϊ���е�ԭ�򣬵�����ʦһ����Ҫ�����ܶ�ѧ������������ʦ���Ǻܸ��ӵ���һ���������ǻ㱨ѧϰ�������Ա�ͬ���ҵ�������ʦ��ȷʵҪ��һЩ������ƽʱʵ���Ҳ�Ҫ�����ڣ���Ȼ����������ʵϰ����Ȼ�ҵ�ʵϰ���ƻ�ͨ��������<br>�ðɣ�������������ʵ���Ұ������ˡ�<br>ʵ���Ҹ��ݸ�����Ȥ�����˷��飬���ŵ�spark��������û���ϣ����˸���Ȥ��Android�顣˵����һֱ��Android����Ȥ��Ҳ���Ժ���ŪAndroid�ˡ�<br>����Android��������ǰ�����Լ���Ȥ������û��ϵͳ��ѧϰ�����������������ٶȡ��ȸ����̡�����ѧ��ÿ�ܻ������ǲ���һЩ������������Щ���񣬲�������ppt����һ�����㱨����ʦ�����о�ȷʵѧ���˲��ٶ�����<br>˵˵�����ĵ����԰ɣ���Ϊ�ǵ�ʦ���ƣ�ʵ���Һ͹�˾�����ģ��������Լ����˺ܶࡣ5��ͬѧһ��ȥ�ģ�û��һ��һ�������ԣ�����һ�����Եġ���Ϊ�Ҽ�����û�д����ݿ����ľ�����ֻ�ܵ�ǰ��ȥ�ˣ�����ֻ��������ְλ�������ܶ���ǰ�˵��������Ƚ��ٰɣ��ұ��ʵ�������Ҳ���࣬��Ҫ������Χ���Ŵ��������ġ�<br>��˵����ǰ����׼�������죬��׼�������㷨֪ʶ��ǰ��֪ʶ����Ȼһ��Ҳû�ʵ���Ҳ�ǱȽϲҡ����������ֻ������Ǻ�����ʱ�����š�<br>��������ҪȥŪ��ְ������Ҳ������Ϊ�����������е���ĩ�ˡ��о��Ժ�����æ��Ҫæ��ʵϰ������ʵ�������񣬿������񣬻����㷨ѧϰ���񡣡���<br>�������Ҹо�æһ���ų�ʵ����ŵ�ʱ����Ҳֻ�����˷�ʱ��</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-22-写写日记.md" data-id="cjct5ua2b000goou7kxrqev9w" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-10-12-学习android之四大核心组件" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-12-学习android之四大核心组件.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.398Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-12-学习android之四大核心组件.md">学习android之四大组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习android之四大组件"><a href="#学习android之四大组件" class="headerlink" title="学习android之四大组件"></a>学习android之四大组件</h1><p>Android开发中，四大组件的开发是基础。这四大组件分别是Activity，Service，Broadcast Receiver，Content Provider。其中最重要的应该是Activity和Service，此外还有个重要组件intent也很重要</p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><ul>
<li>Activity的生命周期<br>这里有一个经典的图，图片来自网络<br><img src="http://wx1.sinaimg.cn/mw690/80b7efb6gy1fkfqv4f8w7j20fw0ctmxs.jpg" alt="生命周期"></li>
</ul>
<p>一个Activity的启动顺序<br>    onCreate()——&gt;onStart()——&gt;onResume()</p>
<p>当另一个Activity启动时：<br>    第一个Activity Onpause()—&gt;第二个Activity onCreate()——&gt;onStart()——&gt;onResume()—&gt;第一个Activity onStop()</p>
<p>当返回到第一个Activity时：<br>    第二个Activity onPause() ——&gt; 第一个Activity　onRestart()——&gt;onStart()——&gt;onResume()<br>    ——&gt;第二个Activity   onStop()——&gt;onDestroy()</p>
<p>一个Activity的销毁顺序:<br>    （情况一）onPause()——&gt;<process killed=""><br>    （情况二）onPause()——&gt;onStop()——&gt;<process killed=""><br>    （情况三）onPause()——&gt;onStop()——&gt;onDestroy()</process></process></p>
<p>在Android开发中，开发者并不能控制Activity处于哪一种状态，但是可以通过onXXX()这样的方法获取到一个活动状态发生变化的信息</p>
<p>onCreate ：当活动第一次启动的时候，触发该方法，可以在此时完成活动的初始化工作。<br>onCreate 方法有一个参数，该参数可以为空（ null ），也可以是之前调用 onSaveInstanceState()方法保存的状态信息。</p>
<p>onStart ：该方法的触发表示所属活动将被展现给用户,在活动由不可见变为可见的时候调用</p>
<p>onResume ：在活动准备好和用户进行交互的时候，触发该方法。此时的活动一定位于返回栈的栈顶，并处于<br>运行状态</p>
<p>onPause ：当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，<br>触发该方法。在这个方法中会把一些消耗cpu的资源释放，以及保存一些关键数据，比如正在编辑的数据库记录等。但是这个方法的执行速度要快，不然会影响新的栈顶活动的使用</p>
<p>onStop ：当一个活动完全不可见，触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发onStop 方法。它和onPause的区别是，如果新启动的活动是对话框，则执行onPause。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动。因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。</p>
<p>onRestart ：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。</p>
<p>onDestroy ：当活动销毁的时候，触发该方法。和onStop方法一样，如果内存紧张，<br>系统会直接结束这个活动而不会触发该方法。</p>
<p>onSaveInstanceState ：系统调用该方法，允许活动保存之前的状态，比如说在一串字符串<br>中的光标所处的位置等。 通常情况下，开发者不需要重写覆盖该方法，在默认的实现中，<br>经提供了自动保存活动所涉及到的用户界面组件的所有状态信息。</p>
<ul>
<li><p>Activity栈<br>每个Activity的状态是由它在Activity栈中的位置决定的（这个栈就和数据结构里的栈是一样的后进先出LIFO）<br>看一幅图帮助理解,图来自网络<br><img src="http://wx3.sinaimg.cn/mw690/80b7efb6gy1fkfrs7ixboj20i80dcaam.jpg" alt="Activity栈"></p>
</li>
<li><p>Activity的四种加载模式<br>在android的多activity开发中，activity之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个activity实例，而不是生成大量的重复的activity。加载模式便是决定以哪种方式启动一个跳转到原来某个Activity实例。<br>在android里，有4种activity的启动模式，分别为：<br>standard: 标准模式，一调用startActivity()方法就会产生一个新的实例。</p>
</li>
</ul>
<p>singleTop: 如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity<br>中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。</p>
<p>singleTask: 这个模式很好的解决了singleTop模式的问题，即使不在栈顶，也不会重新产生一个新的实例。<br>当活动的启动模式指定为singleTask，每次启动该活动时系统会先在返回栈中检查是否存在该活动的实例，如果发现已经存在就直接使用该实例，并把在这个活动之上的所以所有活动全部出栈，如果没有就会新建一个实例</p>
<p>singleInstance: 这是比较特殊的一个模式，如果声明为这种模式，则这个Activity会启动在一个单独的栈里面<br>这个可以用来解决共享活动实例的问题。假设我们的程序中有一个活动是允许其他程序调用，如果我们想实现其他程序和我们的程序共享这个活动实例，使用这个模式，会有一个单独的返回栈管理这个活动</p>
<p>启动模式是可以在AndroidManifest.xml中设置的，launchMode属性，默认如果不设置就是standard模式<br>在代码里启动的话，也可以选择启动模式，代码如下：<br>    Intent intent = new Intent(ReorderFour.this, ReorderTwo.class);<br>    intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);<br>    startActivity(intent);<br>主要是通过addFlags方法实现的。FLAG_ACTIVITY_REORDER_TO_FRONT表示只启用一个实例，也就是singleTask</p>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><p>Service是Android中实现程序后台运行的解决方法，非常适合去执行那些不需要和用户交互且需要长期运行的任务，比如下载文件。服务的运行不依赖任何界面，即使程序被切换到了后台，或者打开了一个新的程序，服务依然可以运行。<br>不过，服务是依赖与创建服务的程序进程的，当应用进程被杀掉的时候，服务也会停止。（这也就是为什么我用bilibili下载视频的时候，如果切换到别的界面，下载服务总会暂停）<br>不要被后台概念所迷惑，实际上的服务并不会自动开启线程，所有的代码都是默认运行在主线程中。所以我们要在服务的内部手动创建子线程，并执行具体的任务，否则很容易出现主线程阻塞的情况。<br>先来学习Android的多线程编程知识。</p>
<ul>
<li>线程的基本用法<br>Android里的线程和java的多线程差不多，有这样几种方式。</li>
</ul>
<p>第一种：</p>
<pre><code>class MyThread extends Thread{
    @Override
    public void run(){
        //执行具体的逻辑
    }
}
//启动线程的方法
new MyThread().start();
</code></pre><p>第二种：</p>
<pre><code>class MyThread implements Runnable{
    @Override
    public void run(){
        //执行具体的逻辑
    }
}
//启动线程的方法
MyThread myThread=new MyThread();
new Thread(myThread).start();
</code></pre><p>Thread构造函数接受一个Runnable参数，前面new出的myThread正好是实现了Runnable接口的对象。接着调用start(),run()中的方法就可以在子线程中运行了</p>
<p>第三种：</p>
<pre><code>new Thread(new Runnable{
    @Override
    public void run(){
        //执行具体的逻辑
    }
}).start();
</code></pre><p>这是使用匿名类的方式，更常用也更简单直接</p>
<ul>
<li><p>在子线程中更新ui<br>Android是线程不安全的。如果你在子线程中更新ui，会导致程序崩溃，那应该怎么做呢？<br>Android提供了一套异步消息处理机制，完美解决了在子线程中进行ui操作的难题。看一下代码</p>
<p>  public class MainActivity extends Activity implements View.OnClickListener{</p>
<pre><code>public static final int UPDATE_TEXT=1;
private TextView text;
private Handler handler=new Handler(){
    public void handleMessage(Message msg){
        switch(msg.what){
            case UPDATE_TEXT:
                //进行ui操作
                text.setText(&quot;hi Android&quot;);
                break;
            default:
                break;
        }
    }
};

....

@Override
public void OnClick(View v){
    switch(v.getId()){
        case R.id.change_text:
            new Thread(new Runnable{
                @Override
                public void run(){
                    Message message=new Message();
                    message.what=UPDATE_TEXT;
                    handler.sendMessage(message);//将Message对象发送出去
                }
            }).start();
            break;
        default:
            break;
    }
}
</code></pre><p>  }<br>可以看到在OnClick中，并不是直接修改ui，而是创建了一个Message对象，使用handler的sendMessage方法把这个message发送出去。然后Handler会收到这个信息，并且用handleMessage进行处理，handleMessage中的代码是在主线程中运行的</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-12-学习android之四大核心组件.md" data-id="cjct5ua2b000foou7sfvkc5ae" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-10-11-(Leetcode)Invert Binary Tree" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-11-(Leetcode)Invert Binary Tree.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.390Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-11-(Leetcode)Invert Binary Tree.md">(leetcode)Invert Binary Tree</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-Invert-Binary-Tree"><a href="#leetcode-Invert-Binary-Tree" class="headerlink" title="(leetcode)Invert Binary Tree"></a>(leetcode)Invert Binary Tree</h2><p>#一些废话<br>这题就是传说中那个难倒那个大牛的一题，反转二叉树。其实我看到题也不会，慢慢积累吧。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Invert a binary tree.</p>
<pre><code>4
</code></pre><p>   /   \<br>  2     7<br> / \   / \<br>1   3 6   9<br>to<br>     4<br>   /   \<br>  7     2<br> / \   / \<br>9   6 3   1</p>
<pre><code>Google: 90% of our engineers use the software you wrote (Homebrew), but you can’t invert a binary tree on a whiteboard so fuck off.
</code></pre><p>题意通过例子很容易懂，就是交换二叉树的左右节点，这题有递归和非递归两种方法，都不难实现</p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><p>递归版本：<br>    class Solution {<br>    public:<br>        TreeNode<em> invertTree(TreeNode</em> root) {<br>            if(root){<br>                invertTree(root-&gt;left);<br>                invertTree(root-&gt;right);<br>                swap(root-&gt;left,root-&gt;right);<br>            }<br>            return root;<br>        }<br>    };</p>
<p>非递归版本：<br>    class Solution {<br>    public:<br>        TreeNode<em> invertTree(TreeNode</em> root) {<br>            stack<treenode*> s;<br>            s.push(root);<br>            while(!s.empty()){<br>                TreeNode* p=s.top();<br>                s.pop();<br>                if(p){<br>                    s.push(p-&gt;left);<br>                    s.push(p-&gt;right);<br>                    swap(p-&gt;left,p-&gt;right);<br>                }<br>            }<br>            return root;<br>        }<br>    };</treenode*></p>
<p>递归版本的代码更加简洁，但是不是很容易理解，emmm一层层的循环嵌套让我有点晕。非递归的版本使用了栈，就是树的遍历，在遍历的过程中交换了左右节点。</p>
<h1 id="关于以后的一些想法"><a href="#关于以后的一些想法" class="headerlink" title="关于以后的一些想法"></a>关于以后的一些想法</h1><p>其实在考研结束以后，我就开始纠结这个问题了。以后是做安卓开发还是web开发，还是学习大数据，数据挖掘这类？想了很久，直到今天。看了一些博客，一些论坛上的讨论，有点想法了。</p>
<ul>
<li>不管以后想做什么，算法始终是基础，基础就是牢固了学别的都很快。算法不仅是基础，也是面试必考的内容！所以学习算法是首要任务</li>
<li>除了算法以外，操作系统，计算机网络，数据库也是基础，这些知识也需要牢固！</li>
<li>关于是学习安卓还是web，或是大数据，我都可以接触一下，其实安卓和web以前已经有一定的基础了。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-11-(Leetcode)Invert Binary Tree.md" data-id="cjct5ua1w000eoou7ru4nr8xk" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-10-09-(Leetcode)NextGreaterElement" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-09-(Leetcode)NextGreaterElement.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.369Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-09-(Leetcode)NextGreaterElement.md">(leetcode)496. Next Greater Element I</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="leetcode-496-Next-Greater-Element-I"><a href="#leetcode-496-Next-Greater-Element-I" class="headerlink" title="(leetcode)496. Next Greater Element I"></a>(leetcode)496. Next Greater Element I</h2><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>You are given two arrays (without duplicates) nums1 and nums2 where nums1’s elements are subset of nums2. Find all the next greater numbers for nums1’s elements in the corresponding places of nums2.</p>
<p>The Next Greater Number of a number x in nums1 is the first greater number to its right in nums2. If it does not exist, output -1 for this number.</p>
<p>Example 1:<br>Input: nums1 = [4,1,2], nums2 = [1,3,4,2].<br>Output: [-1,3,-1]<br>Explanation:<br>    For number 4 in the first array, you cannot find the next greater number for it in the second array, so output -1.<br>    For number 1 in the first array, the next greater number for it in the second array is 3.<br>    For number 2 in the first array, there is no next greater number for it in the second array, so output -1.<br>Example 2:<br>Input: nums1 = [2,4], nums2 = [1,2,3,4].<br>Output: [3,-1]<br>Explanation:<br>    For number 2 in the first array, the next greater number for it in the second array is 3.<br>    For number 4 in the first array, there is no next greater number for it in the second array, so output -1.<br>Note:<br>All elements in nums1 and nums2 are unique.<br>The length of both nums1 and nums2 would not exceed 1000.<br>这题下午在看的时候感觉能做，晚上回来就被打脸了。。。我能想到的解法自然是比较基础的遍历两个数组，从第一个数组中拿一个数到第二个数组中做比较，先是找到这个数字，然后看这个数字后面有没有比它更大的数字，如果有，就放到结果集里，如果没有，就放-1到结果集中。<br>事实上，两层嵌套的遍历会带来很多问题。<br>我的天那。。。东拼西凑凑出来了。。。今晚不想写了，明天在看大佬的解法吧</p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><pre><code>class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) {
        vector&lt;int&gt; res;

        for(int i=0;i&lt;findNums.size();i++){
            bool flag=false;
            for(int j=0;j&lt;nums.size();j++){
                if(findNums[i]==nums[j]){
                    for(int x=j;x&lt;nums.size();x++){
                        if(findNums[i]&lt;nums[x+1]&amp;&amp;x+1&lt;nums.size()){
                            res.push_back(nums[x+1]);
                            flag=true;
                            break;
                        }
                    }
                    if(flag==false) res.push_back(-1);
                }
            }
        }
        return res;
    }
};
</code></pre><p>方法和我上面说的一样，实现起来比较麻烦，嵌套了好几层for循环，效率很低，虽然强行ac了</p>
<h1 id="大神的代码"><a href="#大神的代码" class="headerlink" title="大神的代码"></a>大神的代码</h1><pre><code>class Solution {
public:
    vector&lt;int&gt; nextGreaterElement(vector&lt;int&gt;&amp; findNums, vector&lt;int&gt;&amp; nums) {
        stack&lt;int&gt; s;
        unordered_map&lt;int, int&gt; m;
        for (int n : nums) {
            while (s.size() &amp;&amp; s.top() &lt; n) {
                m[s.top()] = n;
                s.pop();
            }
            s.push(n);
        }
        vector&lt;int&gt; ans;
        for (int n : findNums) ans.push_back(m.count(n) ? m[n] : -1);
        return ans;
    }
};
</code></pre><p>可见使用了stack和unordered_map这两个数据类型（虽然前面已经做过不少几次这些数据类型的题了，但是我还是难以主动使用）<br>map 用来存放nums里面的数字，stack起到了一个中间商的作用<br>在while循环中，把符合条件的数字存储到了map里面。当第一个for循环结束的时候，就已经把nums里的数字归好类了。因为findnums是nums的子集，再遍历一次findnums就可以轻松的写出答案。<br>关键点是第一个for循环，其实按照题目规则，比如【1，3，4，2】这个序列，只有1有Greater num，是3。。</p>
<h2 id="解释的不是很明白，这个做法很难想到啊"><a href="#解释的不是很明白，这个做法很难想到啊" class="headerlink" title="解释的不是很明白，这个做法很难想到啊"></a>解释的不是很明白，这个做法很难想到啊</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-09-(Leetcode)NextGreaterElement.md" data-id="cjct5ua1w000doou7w8v4xej1" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-10-07-学习c++之unordered_set" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-07-学习c++之unordered_set.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.354Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-07-学习c++之unordered_set.md">学习C++之unordered_set</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="学习C-之unordered-set"><a href="#学习C-之unordered-set" class="headerlink" title="学习C++之unordered_set"></a>学习C++之unordered_set</h2><p>最近在leetcode上做题的时候发现了一些c++的新知识，利用这些新的知识可以更方便的解题，比如unordered_set。我们从leetcode题目出发</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given an integer array with even length, where different numbers in this array represent different kinds of candies. Each number means one candy of the corresponding kind. You need to distribute these candies equally in number to brother and sister. Return the maximum number of kinds of candies the sister could gain.</p>
<p>Example 1:<br>Input: candies = [1,1,2,2,3,3]<br>Output: 3<br>Explanation:<br>There are three different kinds of candies (1, 2 and 3), and two candies for each kind.<br>Optimal distribution: The sister has candies [1,2,3] and the brother has candies [1,2,3], too.<br>The sister has three different kinds of candies.<br>Example 2:<br>Input: candies = [1,1,2,3]<br>Output: 2<br>Explanation: For example, the sister has candies [2,3] and the brother has candies [1,1].<br>The sister has two different kinds of candies, the brother has only one kind of candies.<br>Note:</p>
<p>The length of the given array is in range [2, 10,000], and will be even.<br>The number in given array is in range [-100,000, 100,000].</p>
<p>这个题意不是很容易懂，给偶数个糖果，要平均的分给妹妹和弟弟，然后不同的数字表示不同的糖果种类。要求出这样分配种类最多有几种。</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>讲道理，我是没什么思路的。。然后看discuss里面的大神给的一些解法，看到了很多使用unordered_set这个类。</p>
<h1 id="大佬AC代码"><a href="#大佬AC代码" class="headerlink" title="大佬AC代码"></a>大佬AC代码</h1><pre><code>class Solution {
public:
    int distributeCandies(vector&lt;int&gt;&amp; candies) {
        unordered_set&lt;int&gt; kinds;
        for(int kind:candies){
            kinds.insert(kind);
        }
        return min(kinds.size(),candies.size()/2);
    }
};
</code></pre><h1 id="分析代码"><a href="#分析代码" class="headerlink" title="分析代码"></a>分析代码</h1><p>这个代码真的是很简洁了，主要是unordered_set的使用，在for循环遍历candies的时候，把每一个candy的kind插入kinds。为了弄明白insert是怎么执行的，我在vs里实验了一下。如果是【112233】这样的，插入后，kinds的size是3，相同的数只保存一个因为它是存储唯一（Unique，即无重复）元素的关联容器</p>
<h1 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h1><p>无序集合（Unordered Set）容器是一个存储唯一（Unique，即无重复）元素的关联容器（Associative container），容器中的元素无特别的次序关系。该容器允许基于值地快速元素检索。</p>
<h2 id="容器特性："><a href="#容器特性：" class="headerlink" title="容器特性："></a>容器特性：</h2><pre><code>关联（Associative）

关联容器中的元素是通过主键（Key）而不是它们在容器中的绝对位置来引用的。

无序（Unordered）

无序容器通过 hash 表来组织它们的元素，允许通过主键快速地访问元素。

集合（Set）

元素的值同时可以用来标志对应的元素。

键唯一（Unique keys）

容器中不存在两个元素有相同的主键。

能够感知内存分配器的（Allocator-aware）

容器使用一个内存分配器对象来动态地处理它的存储需求。
</code></pre><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><p>在一个 unordered_set 容器中，元素的值同时可以用来标志对应的元素（即值是自身的主键），每个值必须是唯一的。主键是不可修改的，因此在 unordered_set 中的元素不能被逐个修改（所有元素保持恒定），但是可以删除某个元素或插入新的元素。</p>
<p>在 unordered_set 内部，元素不会按任何顺序排序，而是通过元素值的 hash 值将元素分组放置到各个槽（Bucket，也可译成“桶”）中，这样就能通过元素值快速地访问各个对应的元素（平均耗时为一个常量，即时间复杂度为 O(1)）。</p>
<p>在访问容器中的某个元素时，unordered_set 容器比 set 容器高效，而在迭代容器元素的某个子集时，前者比后者稍微低效了一点。</p>
<p>unordered_set 容器支持正向迭代。</p>
<h2 id="详细介绍以及代码例子"><a href="#详细介绍以及代码例子" class="headerlink" title="详细介绍以及代码例子"></a>详细介绍以及代码例子</h2><p><a href="http://classfoo.com/ccby/article/qNNOJ" target="_blank" rel="noopener">http://classfoo.com/ccby/article/qNNOJ</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-07-学习c++之unordered_set.md" data-id="cjct5ua1g000coou7qaoa97nd" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-10-05-(Leetcode)KeyboardRow" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-05-(Leetcode)KeyboardRow.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.333Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-05-(Leetcode)KeyboardRow.md">(Leetcode)Keyboard Row解题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Leetcode-Keyboard-Row解题记录"><a href="#Leetcode-Keyboard-Row解题记录" class="headerlink" title="(Leetcode)Keyboard Row解题记录"></a>(Leetcode)Keyboard Row解题记录</h2><p>这是一题字符串有关的题目，我只想到了笨方法，而且实现起来比较复杂，感觉写出来需要很久</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given a List of words, return the words that can be typed using letters of alphabet on only one row’s of American keyboard like the image below.</p>
<p>Example 1:</p>
<p>Input: [“Hello”, “Alaska”, “Dad”, “Peace”]<br>Output: [“Alaska”, “Dad”]</p>
<p>Note:</p>
<p>You may use one character in the keyboard more than once.<br>You may assume the input string will only contain letters of alphabet.</p>
<p>题意是输入一些单词，返回那些字母全在键盘上同一行的单词，比较好懂</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>思路很清晰，键盘上每一行的字母都是确定的，把每一行都存储到数组里面，然后遍历单词，就可以知道单词的字母在哪一行了，如果所有字母不在同一行则不符合规则。<br>事实上这样的效率会比较低，需要遍历单词，还需要遍历每一行的字母，嵌套遍历了。后来在网上看到别的解法，思路相似，但是使用unordered_set count可以快速得知单词里的字母是否在某一行中。需要补充一些c++的语法知识了。</p>
<h2 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h2><h3 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h3><p>vector(向量): C++中的一种数据结构,确切的说是一个类.它相当于一个动态的数组,当程序员无法知道自己需要的数组的规模多大时,用其来解决问题可以达到最大节约空间的目的.<br>用法:</p>
<p>1.文件包含:<br>    首先在程序开头处加上#include<vector>以包含所需要的类文件vector还有一定要加上using namespace std;<br>2.变量声明:<br>    2.1 例:声明一个int向量以替代一维的数组:vector <int> a;(等于声明了一个int数组a[],大小没有指定,可以动态的向里面添加删除)。<br>    2.2 例:用vector代替二维数组.其实只要声明一个一维数组向量即可,而一个数组的名字其实代表的是它的首地址,所以只要声明一个地址的向量即可,即:vector <int *=""> a.同理想用向量代替三维数组也是一样,vector <int**>a;再往上面依此类推.</int**></int></int></vector></p>
<p>3.具体的用法以及函数调用:</p>
<pre><code>3.1 如何得到向量中的元素?其用法和数组一样:
例如:
    vector &lt;int *&gt; a
    int b = 5;
    a.push_back(b);//该函数下面有详解
    cout&lt;&lt;a[0];       //输出结果为5

        push_back   在数组的最后添加一个数据
        pop_back    去掉数组的最后一个数据 
        at                得到编号位置的数据
        begin           得到数组头的指针
        end             得到数组的最后一个单元+1的指针
        front        得到数组头的引用
        back            得到数组的最后一个单元的引用
        max_size     得到vector最大可以是多大
        capacity       当前vector分配的大小
        size           当前使用数据的大小
        resize         改变当前使用数据的大小，如果它比当前使用的大，者填充默认值
        reserve      改变当前vecotr所分配空间的大小
        erase         删除指针指向的数据项
        clear          清空当前的vector
        rbegin        将vector反转后的开始指针返回(其实就是原来的end-1)
        rend          将vector反转构的结束指针返回(其实就是原来的begin-1)
        empty        判断vector是否为空
        swap         与另一个vector交换数据

     3.2  详细的函数实现功能：其中vector&lt;int&gt; c.
            c.clear()         移除容器中所有数据。
            c.empty()         判断容器是否为空。
            c.erase(pos)        删除pos位置的数据
            c.erase(beg,end) 删除[beg,end)区间的数据
            c.front()         传回第一个数据。
            c.insert(pos,elem)  在pos位置插入一个elem拷贝
            c.pop_back()     删除最后一个数据。
            c.push_back(elem) 在尾部加入一个数据。
            c.resize(num)     重新设置该容器的大小
            c.size()         回容器中实际数据的个数。
            c.begin()           返回指向容器第一个元素的迭代器
            c.end()             返回指向容器最后一个元素的迭代器
</code></pre><h3 id="unordered-set"><a href="#unordered-set" class="headerlink" title="unordered_set"></a>unordered_set</h3><p>C++11中出现了两种新的关联容器:unordered_set和unordered_map，其内部实现与set和map大有不同，set和map内部实现是基于RB-Tree，而unordered_set和unordered_map内部实现是基于哈希表(hashtable)，由于unordered_set和unordered_map内部实现的公共接口大致相同，所以本文以unordered_set为例。<br>unordered_set是基于哈希表，因此要了解unordered_set，就必须了解哈希表的机制。<br>哈希表是根据关键码值而进行直接访问的数据结构，通过相应的哈希函数(也称散列函数)处理关键字得到相应的关键码值，关键码值对应着一个特定位置，用该位置来存取相应的信息，这样就能以较快的速度获取关键字的信息。<br>比如：现有公司员工的个人信息（包括年龄），需要查询某个年龄的员工个数。由于人的年龄范围大约在[0，200]，所以可以开一个200大小的数组，然后通过哈希函数得到key对应的key-value，这样就能完成统计某个年龄的员工个数。<br>而在这个例子中，也存在这样一个问题，两个员工的年龄相同，但其他信息（如：名字、身份证）不同，通过前面说的哈希函数，会发现其都位于数组的相同位置，这里，就涉及到“冲突”。<br>准确来说，冲突是不可避免的，而解决冲突的方法常见的有：开发地址法、再散列法、链地址法(也称拉链法)。而unordered_set内部解决冲突采用的是—-链地址法，当用冲突发生时把具有同一关键码的数据组成一个链表。</p>
<h3 id="它的count方法"><a href="#它的count方法" class="headerlink" title="它的count方法"></a>它的count方法</h3><p>if an element with a value equivalent to k is found, or zero otherwise.如果一个元素的值和k是相等的，就返回1，否则返回0.</p>
<h1 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h1><pre><code>class Solution {
public:
    vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) {
        unordered_set&lt;char&gt; row1 {&apos;q&apos;, &apos;w&apos;, &apos;e&apos;, &apos;r&apos;, &apos;t&apos;, &apos;y&apos;,&apos;u&apos;, &apos;i&apos;, &apos;o&apos;, &apos;p&apos;};
        unordered_set&lt;char&gt; row2 {&apos;a&apos;, &apos;s&apos;, &apos;d&apos;, &apos;f&apos;, &apos;g&apos;, &apos;h&apos;, &apos;j&apos;, &apos;k&apos;, &apos;l&apos;}; 
        unordered_set&lt;char&gt; row3 { &apos;z&apos;, &apos;x&apos;, &apos;c&apos;, &apos;v&apos;, &apos;b&apos; ,&apos;n&apos;, &apos;m&apos;};
        //使用unordered_set存储每一行的字母

        vector&lt;unordered_set&lt;char&gt;&gt; rows {row1, row2, row3};
        //再把哈希表放到vector里

        vector&lt;string&gt; validWords;
        for(int i=0; i&lt;words.size(); ++i){
            //遍历单词
            int row=0;

            for(int k=0; k&lt;3; ++k){
                if(rows[k].count((char)tolower(words[i][0])) &gt; 0) row = k;
                //tolower函数可以把大写字母转换成小写
            }

            validWords.push_back(words[i]);
            //把单词放到validwords里面
            for(int j=1; j&lt;words[i].size(); ++j){

                if(rows[row].count((char)tolower(words[i][j])) == 0){
                    validWords.pop_back();//不符合要求的单词弹出
                    break;
                }
            }

        }
        return validWords;
    }
};
</code></pre><h3 id="AC代码理解"><a href="#AC代码理解" class="headerlink" title="AC代码理解"></a>AC代码理解</h3><p>这段代码主要需要理解的就是三个循环，第一个大循环是遍历单词，第二个循环是遍历rows，找到单词的第一个字母所在行，并且记录下行号，第三个循环是遍历单词的每一个字母，第一个字母所在行已经确定了，后面的也必须在这一行，否则不合格，弹出这个单词</p>
<h1 id="优化解法"><a href="#优化解法" class="headerlink" title="优化解法"></a>优化解法</h1><pre><code>class Solution {
public:
vector&lt;string&gt; findWords(vector&lt;string&gt;&amp; words) 
{
    vector&lt;string&gt; res;

    for(auto str : words)
    {
        bool r1 = str.find_first_of(&quot;QWERTYUIOPqwertyuiop&quot;) == string::npos ? false : true;
        bool r2 = str.find_first_of(&quot;ASDFGHJKLasdfghjkl&quot;) == string::npos ? false : true;
        bool r3 = str.find_first_of(&quot;ZXCVBNMzxcvbnm&quot;) == string::npos ? false : true;

        if(r1 + r2 + r3 == 1)
            res.push_back(str);
    }

    return res;
}

};
</code></pre><h2 id="关于优化解法"><a href="#关于优化解法" class="headerlink" title="关于优化解法"></a>关于优化解法</h2><p>优化解法看上去都是很简洁啊，膜拜大佬。这个只需要一个循环，遍历单词，str是每一个单词，而对于find_first_of这个方法，我也是不知道。。。查了一波</p>
<p>其实这个也比较好理解，就是每个单词查找它是否在某一行。。。不是很理解str.find_first_of(“QWERTYUIOPqwertyuiop”)是怎么运行的准备试验一下，emmmm，懂了！<br>bool r1 = str.find_first_of(“QWERTYUIOPqwertyuiop”) == string::npos ? false : true;<br>bool r2 = str.find_first_of(“ASDFGHJKLasdfghjkl”) == string::npos ? false : true;<br>bool r3 = str.find_first_of(“ZXCVBNMzxcvbnm”) == string::npos ? false : true;<br>这三行是核心，用str，也就是每个单词，去寻找它里面的字母是否在这三行里，只有全在一行里，才能使r1 + r2 + r3 == 1<br>所以判断成功</p>
<p>以下是查找的资料：<br>string 类提供字符串处理函数，利用这些函数，程序员可以在字符串内查找字符，<br>提取连续字符序列(称为子串)，以及在字符串中删除和添加。我们将介绍一些主要函数。</p>
<p>1.函数find_first_of()和 find_last_of() 执行简单的模式匹配<br>例如：在字符串中查找单个字符c。<br>函数find_first_of() 查找在字符串中第1个出现的字符c，而函数find_last_of()查找最后<br>一个出现的c。匹配的位置是返回值。如果没有匹配发生，则函数返回-1.</p>
<pre><code>int find_first_of(char c, int start = 0):
    查找字符串中第1个出现的c,由位置start开始。
    如果有匹配，则返回匹配位置；否则，返回-1.默认情况下，start为0，函数搜索
    整个字符串。

int find_last_of(char c):
    查找字符串中最后一个出现的c。有匹配，则返回匹配位置；否则返回-1.
    该搜索在字符末尾查找匹配，所以没有提供起始位置。
</code></pre><p>string::npos好像就是-1？static const size_t npos = -1;  </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-05-(Leetcode)KeyboardRow.md" data-id="cjct5ua1g000boou79kf0nhd2" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-10-04-学习java之iterable" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-04-学习java之iterable.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.319Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-04-学习java之iterable.md">学习java之iterable</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习java之iterable"><a href="#学习java之iterable" class="headerlink" title="学习java之iterable"></a>学习java之iterable</h1><p>##一些废话<br>十一废了几天以后有点良心不安，打开spark组的任务，看到里面有iterable的学习计划。emm，我的java学的很不扎实，只会一些基础语法，乘此机会，学习一下吧</p>
<h2 id="学习iterable和iterator"><a href="#学习iterable和iterator" class="headerlink" title="学习iterable和iterator"></a>学习iterable和iterator</h2><p>从语法上来看iterable是可以迭代的意思，而iterator是迭代者，也就是迭代器的意思。</p>
<h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>iterator是提供迭代机制的对象，具体如何迭代都是iterator接口规范的<br>它包含三个方法：hasNext,next,remove.remove用到的比较少</p>
<ul>
<li>每次迭代前，先调用hasNext()探测是否迭代到终点。</li>
<li>next方法不仅要返回当前元素，还要后移游标cursor</li>
<li>remove方法用来删除最近一次迭代出的元素</li>
<li>迭代出的元素是原集合中元素的拷贝（重要）</li>
<li>需要配合foreach使用<br>迭代的细节，需要理解的：</li>
<li>hasNext,next,remove的调用顺序</li>
<li><p>迭代出的元素是原集合中元素的拷贝（重要）</p>
<h3 id="手动迭代的例子，与foreach的原理一样"><a href="#手动迭代的例子，与foreach的原理一样" class="headerlink" title="手动迭代的例子，与foreach的原理一样"></a>手动迭代的例子，与foreach的原理一样</h3><p>  public static void main(String[] args)<br>  {</p>
<pre><code>List&lt;Integer&gt; li = new ArrayList&lt;&gt;();

li.add(1);
li.add(2);
li.add(3);

//不使用foreach 而手动迭代
Iterator&lt;Integer&gt; iter = li.iterator();    //获取ArrayList 的迭代器

while(iter.hasNext())                      //①先探测能否继续迭代
{
    System.out.println(iter.next());       //②后取出本次迭代出的元素

    //invoke  remove()                     //③最后如果需要，调用remove

}
</code></pre><p>  }</p>
<h3 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h3><p>一个集合如果要表明自己可以迭代，可以使用foreach语句，就必须实现iterable接口，表示自己是可以迭代的，要实现iterable接口，需要为foreach语句提供一个迭代器。这个迭代器是用接口定义的iterator方法提供的。iterator方法需要返回一个iterator对象</p>
</li>
</ul>
<h3 id="迭代出来的元素都是原来集合元素的拷贝"><a href="#迭代出来的元素都是原来集合元素的拷贝" class="headerlink" title="迭代出来的元素都是原来集合元素的拷贝"></a>迭代出来的元素都是原来集合元素的拷贝</h3><p>Java集合中保存的元素实质是对象的引用(可以理解为C中的指针)，而非对象本身。</p>
<p>迭代出的元素也就都是 引用的拷贝，结果还是引用。那么，如果集合中保存的元素是可变类型的，我们就可以通过迭代出的元素修改原集合中的对象。</p>
<p>而对于不可变类型，如String  基本元素的包装类型Integer 都是则不会反应到原集合中。</p>
<h2 id="小实验，让自己的类支持迭代"><a href="#小实验，让自己的类支持迭代" class="headerlink" title="小实验，让自己的类支持迭代"></a>小实验，让自己的类支持迭代</h2><pre><code>public class Main
{

    public static void main(String[] args)
    {


        MyString s = new MyString(&quot;1234567&quot;);


        for(char c:s)
        {
            System.out.println(c);
        }



    }

}




class MyString implements Iterable&lt;Character&gt;
{

    private int length = 0;
    private String ineers = null;

    public MyString(String s)
    {
        this.ineers = s;
        this.length = s.length();

    }


    @Override
    public Iterator&lt;Character&gt; iterator()
    {


        class iter  implements Iterator&lt;Character&gt;     //方法内部类
        {
            private int cur= 0;


            @Override
            public boolean hasNext()
            {
                return cur != length;
            }

            @Override
            public Character next()
            {

                Character c = ineers.charAt(cur);
                cur++;
                return c;
            }

            public void remove()
            {
                 // do nothing 

            }

        }
        return new iter();     //安装Iterable接口的约定，返回迭代器

    }

}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-04-学习java之iterable.md" data-id="cjct5ua1g0009oou7dvgmkpfk" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-10-02-学习spark大数据之环境安装" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-10-02-学习spark大数据之环境安装.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.314Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-10-02-学习spark大数据之环境安装.md">学习spark大数据之环境安装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习spark大数据之环境安装"><a href="#学习spark大数据之环境安装" class="headerlink" title="学习spark大数据之环境安装"></a>学习spark大数据之环境安装</h1><p>##一些废话<br>十一来了，本来是想去看升旗的，在室友的一致劝导下，我放弃了~~十一的北京各大景点都是很多人，还是选择在寝室打打农药，写写代码比较安逸。emm，最近我们寝室晚上还流行集体看恐怖片了2333，生活过的很是安逸哈。话说现在北邮各个实验室好像都在做大数据，数据挖掘，数据分析这些，我们实验室也有大数据，大家对大数据的学习热情都很高（有点跟风哈哈），反正有时间多学点知识总没有坏处吧，在加入安卓小组后，我也同时开始学习spark了，目前状态是还在安装环境，完全的小白。</p>
<h2 id="学习步骤"><a href="#学习步骤" class="headerlink" title="学习步骤"></a>学习步骤</h2><p>那肯定是先要配置环境了。。在网上找到一篇环境配置的文章，写的还比较详细<a href="http://www.cnblogs.com/shishanyuan/p/4701510.html。我就是跟着这个教程在做。" target="_blank" rel="noopener">http://www.cnblogs.com/shishanyuan/p/4701510.html。我就是跟着这个教程在做。</a> </p>
<h2 id="搭建过程"><a href="#搭建过程" class="headerlink" title="搭建过程"></a>搭建过程</h2><p>过程比较慢。。。感觉绕了很多弯路，比如装好了centos，要把数据传输到虚拟机，折腾vsftpd就弄了很久，但是最后还没有成功！主机可以ping通，但是ftp不通，最后我放弃了ftp，使用vbox自带的增强工具，就可以共享文件夹了，还是很方便的<br>安装vbox自带的增强工具，可能会出现一些错误，根据提示update一些东西吧，比如kernel。。<br>一下是摘自csdn的一片博客<a href="http://blog.csdn.net/buyueliuying/article/details/51645649，图片我这里放上去太麻烦就放弃了。" target="_blank" rel="noopener">http://blog.csdn.net/buyueliuying/article/details/51645649，图片我这里放上去太麻烦就放弃了。</a></p>
<p>1.安装需要的环境<br>方法一：<br>yum update<br>yum install gcc<br>yum install gcc-c++<br>yum install make<br>yum install kernel-headers<br>yum install kernel-devel</p>
<p>(一定要先安装gcc和gcc-c++，再安装下面两个kernel，否则kernel无法完全编译)<br>方法二：<br>官方建议使用如下两个命令替换上面多个命令来安装，以确保所需的环境都安装上<br>yum update  #可执行也可不执行<br>yum groupinstall “Development Tools”</p>
<p>2.重启系统<br>reboot</p>
<p>3.挂载并安装 VBoxGuestAdditions.iso<br>需要加载VBoxGuestAdditions，virtualbox安装目录里面会有VBoxGuestAdditions.iso，或者到<a href="http://download.virtualbox.org/virtualbox下载对应版本的增强包" target="_blank" rel="noopener">http://download.virtualbox.org/virtualbox下载对应版本的增强包</a></p>
<p>新增目录<br>mkdir /home/website<br>挂载到CD/DVD虚拟光驱<br>mount -t auto /dev/cdrom /home/website<br>(这里的cdrom是cd的，有时是dvd1，具体有什么光驱到 /dev目录下查看)</p>
<p>转到目录<br>cd /home/website</p>
<p>执行ls目录，此时看到列表中有VBoxLinuxAdditions.run证明挂载成功</p>
<p>sh ./VBoxLinuxAdditions.run<br>等待安装完成</p>
<p>(如果安装结果提示内核错误，尝试 使用 yum update kernel 更新内核,需要reboot后安装VBoxLinuxAdditions)</p>
<p>最后 重启以使 GuestAddition 生效<br>reboot</p>
<p>4.共享文件夹<br>这里共享本机win7的D盘的website文件夹为例，让centos可以访问该目录</p>
<p>挂载<br>mount -t vboxsf wb /home/website<br>切换目录并查看<br>cd /home/website<br>ls<br>如果成功则可以看到本机的文件<br>实现 开机自动挂载<br>vi ~/.bashrc<br>添加一行mount -t vboxsf wb /home/website，保存退出</p>
<h2 id="好像需要3个centos系统建立集群，我感觉我的磁盘空间都不够了，，，先弄一个吧"><a href="#好像需要3个centos系统建立集群，我感觉我的磁盘空间都不够了，，，先弄一个吧" class="headerlink" title="好像需要3个centos系统建立集群，我感觉我的磁盘空间都不够了，，，先弄一个吧"></a>好像需要3个centos系统建立集群，我感觉我的磁盘空间都不够了，，，先弄一个吧</h2>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-10-02-学习spark大数据之环境安装.md" data-id="cjct5ua1g000aoou7bs5oufr7" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-09-28-学习javaweb之spring" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-09-28-学习javaweb之spring.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.291Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-09-28-学习javaweb之spring.md">学习java-web之spring</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="学习java-web之spring"><a href="#学习java-web之spring" class="headerlink" title="学习java-web之spring"></a>学习java-web之spring</h1><p>按照我们组的学习计划，emmmm，明明是安卓开发小组，怎么变成学习java web了？？我也不是很懂，可能是实验室用到的java web会比较多吧。<br>那学就学吧，多学点总是没坏处的，其实是今天不太想做Leetcode了（手动滑稽）。<br>看了一下学习计划，最后任务是使用任一个框架做一个Login的demo，考虑到spring框架那么有名气，那就学习一下吧~</p>
<h2 id="学习步骤"><a href="#学习步骤" class="headerlink" title="学习步骤"></a>学习步骤</h2><p>考虑到我也是有一定java开发基础了，就直接去github下一个demo回来看看吧，感觉那样会学的比较快，嗯。<br>在github很容易就可以搜索到相关的项目，关键词‘java spring Login demo’。down下来后用idea打开，会自动下载需要的框架等等，待他下好就可以工作了。<br>第一个下载的demo有问题，又找了一个成功跑了起来,这里放图片太麻烦了，自行脑补吧。接下来就看看代码是如何实现的。</p>
<h2 id="学习代码"><a href="#学习代码" class="headerlink" title="学习代码"></a>学习代码</h2><p>emmmm，这个代码有点复杂哈，不仅实现了简单的登录和退出，还有注册等内容，所以。。我还是准备找个教程来学习吧~</p>
<h2 id="29号继续学习spring"><a href="#29号继续学习spring" class="headerlink" title="29号继续学习spring"></a>29号继续学习spring</h2><p>昨天开始，就疯狂报错！很气，主要是java.lang.ClassNotFoundException: org.apache.commons.dbcp.BasicDataSource这个错，嗯，应该是少了一个jar包，在网上找了一下，据说除了common这个包还有一个commons-pool.jar这个包！<br>哇，心态蹦了！！！找了这些个文件添加到library里，还是报错。<br>还是没弄好，感觉是和版本有一定关系，mmp终于好了，但是又有另外一个问题了。。错误原因是版本不对，必须是1.2.2版本commons-pool必须是1.3<br>哇！终于搞定了！这个简单的demo，我还是费了不少时间哈哈</p>
<h2 id="总结一下有哪些坑吧"><a href="#总结一下有哪些坑吧" class="headerlink" title="总结一下有哪些坑吧"></a>总结一下有哪些坑吧</h2><ul>
<li>首先是上午那个缺少类的问题，注意版本，还有就是用idea的话，添加新的包，可以选择maven添加，这样可以在线搜索添加，很方便</li>
<li>还有就是注解，在controller类上要加上@Controller注解，在service impl上加上@service 还有别的，就看代码吧</li>
<li>编码也有一个坑。。。默认情况下，post过来的中文会乱码，在网上找到解决办法，挺有效的，在web.xml中加上<br>  <filter><pre><code>    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;encoding&lt;/param-name&gt;
        &lt;param-value&gt;utf-8&lt;/param-value&gt;
    &lt;/init-param&gt;
&lt;/filter&gt;
&lt;filter-mapping&gt;
    &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
&lt;/filter-mapping&gt;
</code></pre></filter></li>
<li>还有一些小坑，根据错误提示就能改好</li>
</ul>
<h3 id="下一篇文章再来分析一下项目代码吧"><a href="#下一篇文章再来分析一下项目代码吧" class="headerlink" title="下一篇文章再来分析一下项目代码吧"></a>下一篇文章再来分析一下项目代码吧</h3>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-09-28-学习javaweb之spring.md" data-id="cjct5ua100007oou74i4ho6os" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="content-2017-09-27-(Leetcode)NumberComplement" class="article article-type-content" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2018-01-24-2017-09-27-(Leetcode)NumberComplement.md" class="article-date">
  <time datetime="2018-01-24T13:16:48.261Z" itemprop="datePublished">2018-01-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2018-01-24-2017-09-27-(Leetcode)NumberComplement.md">(Leetcode)Number Complement解题记录</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Leetcode-Number-Complement解题记录"><a href="#Leetcode-Number-Complement解题记录" class="headerlink" title="(Leetcode)Number Complement解题记录"></a>(Leetcode)Number Complement解题记录</h2><p>又是一题位操作的题目，摩拳擦掌表示应该能做出来。。。不过最后确实是写出来了，不过不是最优解</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>Given a positive integer, output its complement number. The complement strategy is to flip the bits of its binary representation.</p>
<p>Note:<br>The given integer is guaranteed to fit within the range of a 32-bit signed integer.<br>You could assume no leading zero bit in the integer’s binary representation.</p>
<p>Example：<br>    Input: 5<br>    Output: 2<br>    Explanation: The binary representation of 5 is 101 (no leading zero bits), and its complement is 010. So you need to output 2.</p>
<p>题意是输入一个整数，输出一个十进制数，他们的二进制互补</p>
<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>有了昨天位运算的基础，感觉自己应该能做。首先想到的是先&amp;1，然后再进行移位操作，通过&amp;1是否为0，判断二进制尾位是否为0，然后分情况对输出数字进行移位操作。试了一下发现不可行，比如输入2，二进制是10，互补的应该是01，但是移位出的结果还是10，，，放弃这个想法。<br>后面的思路就比较暴力了，，直接把二进制数转换为十进制的。。比较蠢的方法，不过ac了<br>后来在网上看到比较好的解法，是使用mask掩码，使mask^num就可以得到补码！真是很方便，但是我却想不到，完全没想到这种操作，还是太年轻。。</p>
<h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>比较蠢的方法。。。</p>
<pre><code>class Solution {
public:
    int findComplement(int num) {
        int res=0,i=0;
        int ans[32]={0};
        while(num&gt;0){
            if((num&amp;1)==0){
                ans[i++]=1;
            }else
                ans[i++]=0;
            num&gt;&gt;=1;
        }

        int len=i;
        for(int x=0;x&lt;len;x++){
            res+=ans[x]*pow(2,x);
        }
        return res;
    }
};
</code></pre><h1 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h1><p>使用mask和num异或操作，这样就能得到补码，mask的获取是使用移位操作。<br>mask–1为和num二进制位等长的所有位数为1的数（这是一个规律），与num取^可以得到和num相反的数字</p>
<pre><code>class Solution {
public:
    int findComplement(int num) {
        int temp = num, mask = 1;
        while(temp){
            temp &gt;&gt;= 1;
            mask &lt;&lt;= 1;
        }
        return ((mask - 1) ^ num);
    }
};
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://chapter007.github.io/blog/2018-01-24-2017-09-27-(Leetcode)NumberComplement.md" data-id="cjct5ua100008oou7u8wew8bf" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/blog/page/2/">2</a><a class="extend next" rel="next" href="/blog/page/2/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2018/01/">January 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2018-01-24-2017-10-22-写写日记.md">дд�ռ�</a>
          </li>
        
          <li>
            <a href="/blog/2018-01-24-2017-10-12-学习android之四大核心组件.md">学习android之四大组件</a>
          </li>
        
          <li>
            <a href="/blog/2018-01-24-2017-10-11-(Leetcode)Invert Binary Tree.md">(leetcode)Invert Binary Tree</a>
          </li>
        
          <li>
            <a href="/blog/2018-01-24-2017-10-09-(Leetcode)NextGreaterElement.md">(leetcode)496. Next Greater Element I</a>
          </li>
        
          <li>
            <a href="/blog/2018-01-24-2017-10-07-学习c++之unordered_set.md">学习C++之unordered_set</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zhangjie<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>



  </div>
</body>
</html>