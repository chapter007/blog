---
layout: content
title: 学习android之四大组件
---

# 学习android之四大组件
Android开发中，四大组件的开发是基础。这四大组件分别是Activity，Service，Broadcast Receiver，Content Provider。其中最重要的应该是Activity和Service，此外还有个重要组件intent也很重要
# Activity
* Activity的生命周期
这里有一个经典的图，图片来自网络
![生命周期](http://wx1.sinaimg.cn/mw690/80b7efb6gy1fkfqv4f8w7j20fw0ctmxs.jpg)

一个Activity的启动顺序
	onCreate()——>onStart()——>onResume()
	
当另一个Activity启动时：
	第一个Activity Onpause()--->第二个Activity onCreate()——>onStart()——>onResume()--->第一个Activity onStop()
	
当返回到第一个Activity时：
	第二个Activity onPause() ——> 第一个Activity　onRestart()——>onStart()——>onResume() 
	——>第二个Activity   onStop()——>onDestroy()
	
一个Activity的销毁顺序:
	（情况一）onPause()——><Process Killed> 
	（情况二）onPause()——>onStop()——><Process Killed> 
	（情况三）onPause()——>onStop()——>onDestroy()
	
在Android开发中，开发者并不能控制Activity处于哪一种状态，但是可以通过onXXX()这样的方法获取到一个活动状态发生变化的信息

onCreate ：当活动第一次启动的时候，触发该方法，可以在此时完成活动的初始化工作。 
onCreate 方法有一个参数，该参数可以为空（ null ），也可以是之前调用 onSaveInstanceState()方法保存的状态信息。

onStart ：该方法的触发表示所属活动将被展现给用户,在活动由不可见变为可见的时候调用

onResume ：在活动准备好和用户进行交互的时候，触发该方法。此时的活动一定位于返回栈的栈顶，并处于
运行状态

onPause ：当一个正在前台运行的活动因为其他的活动需要前台运行而转入后台运行的时候，
触发该方法。在这个方法中会把一些消耗cpu的资源释放，以及保存一些关键数据，比如正在编辑的数据库记录等。但是这个方法的执行速度要快，不然会影响新的栈顶活动的使用

onStop ：当一个活动完全不可见，触发该方法。如果内存紧张，系统会直接结束这个活动，而不会触发onStop 方法。它和onPause的区别是，如果新启动的活动是对话框，则执行onPause。活动如果没有在前台运行，都将被停止或者Linux管理进程为了给新的活动预留足够的存储空间而随时结束这些活动。因此对于开发者来说，在设计应用程序的时候，必须时刻牢记这一原则。在一些情况下，onPause方法或许是活动触发的最后的方法，因此开发者需要在这个时候保存需要保存的信息。

onRestart ：当处于停止状态的活动需要再次展现给用户的时候，触发该方法。

onDestroy ：当活动销毁的时候，触发该方法。和onStop方法一样，如果内存紧张，
系统会直接结束这个活动而不会触发该方法。

onSaveInstanceState ：系统调用该方法，允许活动保存之前的状态，比如说在一串字符串
中的光标所处的位置等。 通常情况下，开发者不需要重写覆盖该方法，在默认的实现中，
经提供了自动保存活动所涉及到的用户界面组件的所有状态信息。

* Activity栈
每个Activity的状态是由它在Activity栈中的位置决定的（这个栈就和数据结构里的栈是一样的后进先出LIFO）
看一幅图帮助理解,图来自网络
![Activity栈](http://wx3.sinaimg.cn/mw690/80b7efb6gy1fkfrs7ixboj20i80dcaam.jpg)

* Activity的四种加载模式
在android的多activity开发中，activity之间的跳转可能需要有多种方式，有时是普通的生成一个新实例，有时希望跳转到原来某个activity实例，而不是生成大量的重复的activity。加载模式便是决定以哪种方式启动一个跳转到原来某个Activity实例。
在android里，有4种activity的启动模式，分别为：
standard: 标准模式，一调用startActivity()方法就会产生一个新的实例。

singleTop: 如果已经有一个实例位于Activity栈的顶部时，就不产生新的实例，而只是调用Activity
中的newInstance()方法。如果不位于栈顶，会产生一个新的实例。

singleTask: 这个模式很好的解决了singleTop模式的问题，即使不在栈顶，也不会重新产生一个新的实例。
当活动的启动模式指定为singleTask，每次启动该活动时系统会先在返回栈中检查是否存在该活动的实例，如果发现已经存在就直接使用该实例，并把在这个活动之上的所以所有活动全部出栈，如果没有就会新建一个实例

singleInstance: 这是比较特殊的一个模式，如果声明为这种模式，则这个Activity会启动在一个单独的栈里面
这个可以用来解决共享活动实例的问题。假设我们的程序中有一个活动是允许其他程序调用，如果我们想实现其他程序和我们的程序共享这个活动实例，使用这个模式，会有一个单独的返回栈管理这个活动

启动模式是可以在AndroidManifest.xml中设置的，launchMode属性，默认如果不设置就是standard模式
在代码里启动的话，也可以选择启动模式，代码如下：
	Intent intent = new Intent(ReorderFour.this, ReorderTwo.class);
	intent.addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT);
	startActivity(intent);
主要是通过addFlags方法实现的。FLAG_ACTIVITY_REORDER_TO_FRONT表示只启用一个实例，也就是singleTask

# Service
Service是Android中实现程序后台运行的解决方法，非常适合去执行那些不需要和用户交互且需要长期运行的任务，比如下载文件。服务的运行不依赖任何界面，即使程序被切换到了后台，或者打开了一个新的程序，服务依然可以运行。
不过，服务是依赖与创建服务的程序进程的，当应用进程被杀掉的时候，服务也会停止。（这也就是为什么我用bilibili下载视频的时候，如果切换到别的界面，下载服务总会暂停）
不要被后台概念所迷惑，实际上的服务并不会自动开启线程，所有的代码都是默认运行在主线程中。所以我们要在服务的内部手动创建子线程，并执行具体的任务，否则很容易出现主线程阻塞的情况。
先来学习Android的多线程编程知识。
* 线程的基本用法
Android里的线程和java的多线程差不多，有这样几种方式。

第一种：

	class MyThread extends Thread{
		@Override
		public void run(){
			//执行具体的逻辑
		}
	}
	//启动线程的方法
	new MyThread().start();

第二种：

	class MyThread implements Runnable{
		@Override
		public void run(){
			//执行具体的逻辑
		}
	}
	//启动线程的方法
	MyThread myThread=new MyThread();
	new Thread(myThread).start();
Thread构造函数接受一个Runnable参数，前面new出的myThread正好是实现了Runnable接口的对象。接着调用start(),run()中的方法就可以在子线程中运行了

第三种：

	new Thread(new Runnable{
		@Override
		public void run(){
			//执行具体的逻辑
		}
	}).start();
这是使用匿名类的方式，更常用也更简单直接
* 在子线程中更新ui
Android是线程不安全的。如果你在子线程中更新ui，会导致程序崩溃，那应该怎么做呢？
Android提供了一套异步消息处理机制，完美解决了在子线程中进行ui操作的难题。看一下代码

	public class MainActivity extends Activity implements View.OnClickListener{
		public static final int UPDATE_TEXT=1;
		private TextView text;
		private Handler handler=new Handler(){
			public void handleMessage(Message msg){
				switch(msg.what){
					case UPDATE_TEXT:
						//进行ui操作
						text.setText("hi Android");
						break;
					default:
						break;
				}
			}
		};
		
		....
		
		@Override
		public void OnClick(View v){
			switch(v.getId()){
				case R.id.change_text:
					new Thread(new Runnable{
						@Override
						public void run(){
							Message message=new Message();
							message.what=UPDATE_TEXT;
							handler.sendMessage(message);//将Message对象发送出去
						}
					}).start();
					break;
				default:
					break;
			}
		}
	}
可以看到在OnClick中，并不是直接修改ui，而是创建了一个Message对象，使用handler的sendMessage方法把这个message发送出去。然后Handler会收到这个信息，并且用handleMessage进行处理，handleMessage中的代码是在主线程中运行的