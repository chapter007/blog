---
layout: content
title: (Leetcode)HammingDistance解题记录
---

# 算法渣的自我救赎。。
作为一个不折不扣的算法渣，在研究生阶段还是多刷刷Leetcode，不然真是找不到工作了哦。今天上午打开Leetcode，挑了一题emmmm，easy+70%通过率，应该能做。
然而，事实是残酷的，我又跪了。失败是成功之母，嗯！（这句话真是安慰人的至理名言）

# 背景知识的补充，c语言中的位运算
要能做出这题，必须要用到位运算，而我对这一块的知识是空白的。。。恶补
C语言的设计具备了汇编语言的运算能力，它支持全部的位操作符。位操作符是对字节或字中的位进行测试、置位或移位处理，在对微处理器的编程中，特别适合对寄存器、I/O端口进行操作。
6种伟操作符：
<<<<<<< HEAD
（1） & ：按位“与”——仅当两个操作数为1时，结果为1，否则为0。如：1000 1000  & 1000 0001  = 1000 0000；
（2） | ：按位“或”——仅当两个操作数为0时，结果为0，否则为1。如：1000 1000 | 1000 0001 = 1000 1001；
（3） ^：按位“异或”——仅当两个操作数不同时，相应的输出结果才为1，否则为0。如：1000 1000 ^ 1000 0001 = 0000 1001 ；
（4） ~ ：“取反”——把1置为0，0置为1。如：~1000 1000 = 0111 0111；
（5） <<： “左移”——将变量的各位按要求向左移动若干位。如：0000 1000 <<3 = 0100 0000；
（6） >>： “右移”——将变量的各位按要求向右移动若干位。如：0000 1000>>3=0000 0001；
=======

	（1） & ：按位“与”——仅当两个操作数为1时，结果为1，否则为0。如：1000 1000  & 1000 0001  = 1000 0000；
	（2） | ：按位“或”——仅当两个操作数为0时，结果为0，否则为1。如：1000 1000 | 1000 0001 = 1000 1001；
	（3） ^：按位“异或”——仅当两个操作数不同时，相应的输出结果才为1，否则为0。
		       如：1000 1000 ^ 1000 0001 = 0000 1001 ；
	（4） ~ ：“取反”——把1置为0，0置为1。如：~1000 1000 = 0111 0111；
	（5） <<： “左移”——将变量的各位按要求向左移动若干位。如：0000 1000 <<3 = 0100 0000；
	（6） >>： “右移”——将变量的各位按要求向右移动若干位。如：0000 1000>>3=0000 0001；

>>>>>>> 5434b6f41f009aeec59c1af4c8dee7c1616c8503
基础知识，要记牢了

# 题目
The Hamming distance between two integers is the number of positions at which the corresponding bits are different.

Given two integers x and y, calculate the Hamming distance.

Example：
Input: x = 1, y = 4

Output: 2

Explanation:
1   (0 0 0 1)
4   (0 1 0 0)
       ↑   ↑

The above arrows point to positions where the corresponding bits are different.

嗯，题目描述已经够清楚了，我就不解释了。

# 解题思路
给的两个数字，对它们进行异或运算（^）后，结果里有几个1，就是Hamming Distance了。为什么这样呢？1和4异或，得到的是6（0001^0100=0101）,把6写成二进制可以看到有两个1.这样答案就出来了

# 算法

	class Solution {
	public:
	    int hammingDistance(int x, int y) {
		int res=0;
		int z=x^y;
		for(int i=0;i<32;i++){
		    res+=(z>>i)&1;
				//这是遍历z，算出z中1的和
		}
		return res;
	    }
	};
	
# 改进
据说遍历每一位的方法效率并不高，对数字num，使用num&(num-1)可以快速移去bit 1，这样循环num直到为0，循环次数为bit 1的个数，代码也很简单，把上面的for循环换成while

	while(num){
		res++;
		num=num&(num-1);
	}
